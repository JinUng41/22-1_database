# chap 9 : 트랜잭션

## 01. 트랜잭션

### 1-1 트랜잭션이란?

- 트랜잭션의 개념
    - 응용프로그램
        - 명령어들의 집합으로 구성
    - 데이터베이스 응용 프로그램
        - 업무처리에 관련된 세부 프로그램들로 구성
        - 세부적으로 여러 가지의 데이터베이스에 대한 연산 (검색, 삽입, 삭제, 수정)들을 필요로 한다.
    - ***트랜잭션***
        - ***하나의 논리적인 작업 단위를 구성하는 연산들의 집합***
        - 데이터베이스 응용 프로그램은 트랜잭션들의 집합으로 정의
        - 실행 중 멈추거나 중단되지 않은 최소 작업 단위
- 트랜잭션의 필요성
    - 실행이 중단되었다고 가정
        - 계좌이체에 정의된 모든 연산을 완벽하게 실행하던지 아니면 모두 실행하지 않고 처음의 상태로 남아있어야 한다. (all or nothing)
    - 동시에 인출하는 작업을 한다고 가정
        - 다중 사용자 환경에서 하나의 트랜잭션이 동시에 실행되는 다른 트랜잭션에 의해 영향을 받은 결과
    - 트랜잭션이 필요한 이유
        - 원하지 않는 결과가 발생하지 않도록 사전에 방지하기 위해
        - 현재 대부분의 DBMS는 이러한 상황을 방지하기 위한 기능을 갖춤
        - 데이터베이스 개발자는 작업 단위들을 트랜잭션으로 적절히 정의
        - 트랜잭션을 정의함으로써 위와 같은 문제가 발생하지 않도록 사전에 방지하는 것이 DBMS의 몫

### 1-2 트랜잭션이 지켜야 할 조건

- ***ACID property (시험에 나옴)***
    - 트랜잭션이 반드시 지켜야 할 중요한 조건
    - ***원자성 Atomicity***
        - all or nothing → 중간에 멈출 수 없다.
    - ***일관성 Consistency***
        - 데이터베이스의 내용이 일관된 상태로 유지되어야 한다.
    - ***고립성 Isolation***
        - 실행하는 과정에서 갱신한 데이터는 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조할 수 없다.
    - ***지속성 Durability***
        - 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장
- 원자성
    - 실패하거나 성공하거나
    - 장애가 발생되어 중단된 경우 반드시 원래의 상태로 되돌아갈 수 있도록 보장해야 함
- 일관성
    - 완료 후에도 일관된 상태 유지
    - 데이터베이스 개발자는 이러한 상황이 발생하지 않도록 트랜잭션의 단위를 적절히 정의해야 함
- 고립성
    - 실행 중 변경한 데이터는 완료 전까지 다른 트랜잭션이 참조 불가능
    - 문제를 해결하기 위한 방법
        - 동시에 실행되는 각 트랜잭션을 순차적으로 실행
        - 하지만 다중 프로그래밍 환경에서 트랜잭션들을 순차적으로 실행하는 것은 성능 면에서 많은 문제가 있음
        - 따라서 트랜잭션을 동시에 실행하면서 상호간에 간섭이 일어나지 않도록 하는 기법 요구
    - 고립성을 만족하는지 확인하는 방법
        - ***동시에 실행하는 트랜잭션의 실행 결과가 순차적으로 실행된 결과와 동일한지 확인***
- 지속성
    - 결과는 영구적으로 보존
    - 트랜잭션이 완료되면 주기억장치가 아닌 디스크와 같은 보조기억장치에 저장되거나 그렇지 않더라도 시스템 장애가 회복되고 난 후에 어떠한 형태로든지 그 데이터를 복구할 수 있어야 함을 의미 → log (recovery)

### 1-3 트랜잭션의 상태

- 트랜잭션의 상태 종류

| 동작 active | 트랜잭션이 시작되고 연산들이 정상적으로 실행 중인 상태 |
| --- | --- |
| 부분 완료 partially committed | 트랜잭션이 정의된 모든 연산의 실행이 끝난 상태 (지속성 x) |
| 완료 committed | 트랜잭션이 성공적으로 종료된 상태 (지속성 o) |
| 실패 failed | 트랜잭션이 완료되지 못하고 더 이상 실행되지 못하는 상태 |
| 중단 aborted | 트랜잭션이 실해한 후 실행되기 이전으로 복귀된 상태 (rollback) |
- 트랜잭션의 상태 전이도 state transition diagram

![Untitled](Untitled%207.png)

## 02. 동시성 제어

- DBMS는 동시에 사용할 수 있는 사용자의 수에 따라
    - 단일 사용자 DBMS
    - 다중 사용자 DBMS
- ***동시성 제어 concurrency control***
    - 트랜잭션의 실행 순서를 제어
    - 다중 사용자 DBMS에서 매우 중요한 문제
        - 간섭이 발생하여 일관성이 깨지지 않도록 하기 위해

### 2-1 트랜잭션에서의 연산

- read(x)
    - 이름이 x인 데이터베이스 항목을 트랜잭션의 지역변수 x로 읽어 들인다
    - select
- write(x)
    - 지역변수 x에 저장된 값을 데이터베이스 항목 x에 저장한다
    - update
- x는 테이블, 레코드, 필드 등 데이터베이스를 구성하는 임의의 구성 요소가 될 수 있음
- write(x) 연산의 경우, 그 결과가 디스크에 즉시 저장될 수도 있고 그렇지 않을 수도 있다.
    - 대부분 주기억장치의 buffer에 저장

### 2-2 동시성 제어가 필요한 이유

- 트랜잭션들은 각각에 정의된 명령들이 끼어들기 interactive 방식으로 실행
- ***스케줄 schedule***
    - 끼어들기 방식에 의해 실행되는 순서
    - 운영체제의 권한
    - 미리 예측하기 불가능
- 끼어들기 방식은 서로간의 간섭에 의해 잘못된 데이터를 생성할 수가 있다.
- 끼어들기로 인한 문제
    - 갱신 분실
    - 연쇄 복귀
    - 불일치 분석
- ***갱신 분실 lost update***
    
    ![Untitled](Untitled%208.png)
    
- ***연쇄 복귀 cascading rollback***
    - 연쇄 복귀가 발생하는 이유
        - ***완료되지 않는 트랜잭션의 쓰기 연산에 의해 갱신된 데이터를 다른 트랜잭션이 읽었기 때문***
    
    ![Untitled](Untitled%209.png)
    
- ***불일치 분석 inconsistent analysis***
    - ***끼어들기로 인해 일관성이 유지되지 못하는 상황***
    
    ![Untitled](Untitled%2010.png)
    

### 2-3 직렬 가능한 스케줄

- 끼어들기로 인한 문제점 해결
    - 가장 단순한 방법
        - 트랜잭션들을 순차적으로 실행
            - 끼어들기를 허용하지 않음
- ***직렬 스케줄 serial schedule p376***
    - ***각 트랜잭션들의 연산들이 끼어들기 방식으로 실행되지 않고 순차적으로 실행되는 스케줄***
- ***직렬 가능한 스케줄 serializable schedule p377***
    - ***직렬 스케줄과 실행 결과가 동일한 스케줄***
    - 병행 수행 (끼어들기)를 최대한 보장
    - 스케줄에 나타난 연산들의 순서를 전체적인 실행 결과에 영향을 미치지 않도록 바꾸어 보는 것
    - 이 때 주어진 스케줄이 직렬 스케줄로 변환되면 직렬 가능한 스케줄임
- ***직렬 가능한 스케줄인지 확인하는 방법 p377~379***
    - C1과 C2가 서로 다른 데이터 항목에 대한 연산일 경우 교환 가능
    - C1과 C2가 같은 데이터 항목에 대한 연산일 경우
        - 모두 read 연산일 경우 교환 가능
        - ***하나라도 write 연산일 경우 교환 불가능***
- 모든 스케줄이 직렬 가능한 스케줄이 되도록 제어하는 방법
    - ***잠금 locking - 비관적***
        - ***트랜잭션의 실행 순서를 강제로 제어***
    - ***타임스탬프 timestamp - 낙관적***
        - ***트랜잭션들이 실행 순서를 제어하기보다는 최대한 병행 수행을 보장하다가 직렬 가능한 스케줄에 위배될 가능성이 있으면 트랜잭션의 실행을 취소하는 방법***
    - 현재 대부분의 DBMS에서는 잠금 기법을 이용

### 2-4 잠금

- 잠금 p380
    - ***하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션들이 동시에 접근하지 못하도록 독점하는 기법***
    - 잠금이 걸린 데이터
        - 잠금을 실행한 트랜잭션만 독점적으로 접근
    - lock, unlock
- 잠금의 종류 p381~382
    - ***공유 잠금 shared lock, S-lock***
        - ***read 연산 가능, write 연산 불가능***
        - ***하나의 데이터에 여러개의 공유 잠금 가능***
    - ***배타 잠금 exclusive lock, X-lock***
        - ***read, write 연산 모두 가능***
        - 하나의 데이터에 대해서 하나의 배타 잠금만 가능
    
    ![Untitled](Untitled%2011.png)
    
- 잠금의 한계 p383~386
    - 단순한 잠금 만으로 직렬 가능한 스케줄을 보장하는 것은 아니다
    - 교착상태 deadlock 발생 가능
        - 교착 상태에 빠지면 외부에서 강제적으로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 영원히 대기 상태로 남게 됨
- ***2단계 잠금 규약 2-Phase Locking Protocol, 2PL p386~390***
    - 직렬 가능한 스케줄을 보장
    - ***확장 단계 growing phase***
        - ***lock 연산 수행 가능, unlock 불가능***
    - ***축소 단계 shrinking phase***
        - ***unlock 가능, lock 불가능***
    - ***트랜잭션은 확장 단계로 시작하여 축소 단계로 끝난다.***
- 2PL과 직렬 가능한 스케줄
    - 2PL은 직렬 가능한 스케줄을 보장하지만, 반대로 이 규약이 지켜지지 않는다고 해서 직렬 가능한 스케줄을 아예 생성하지 못하는 것은 아니다.
    - 2PL은 직렬 가능한 스케줄의 충분조건
- 2PL의 한계
    - 교착상태 방지 불가능
        - 가장 단순한 해결방법 - 각 트랜잭션을 시작하기 전에 모든 필요한 잠금을 동시에 설정
        - 교착상태 방지를 위한 다른 방법 사용
            - 교착상태 회피 deadlock avoidance
            - 교착상태 탐지 deadlock detection
    - 연쇄 복귀 문제 발생
        - 해결 방안 - ***strict 2PL***
            - 모든 X-lock에 대한 unlock 연산을 트랜잭션이 완료된 후에 실행
- ***잠금 단위 locking granularity***
    - ***잠금의 대상이 되는 데이터 객체의 크기***
        - ex) 필드, 레코드, 디스크 블록, 테이블, 데이터베이스
    - 잠금 단위가 너무 크면
        - 동시성 수준 낮아짐
        - 제어기법 간단
    - 잠금 단위가 너무 작으면
        - 동시성 수준 높아짐
        - 관리가 매우 복잡
    - 따라서 잠금 단위를 여러 단계를 정해놓고 혼용하여 사용
- 사용자는 트랜잭션의 시작과 끝을 정의 (락은 사용자가 걸 필요 없다) → 락을 걸어주는 과정은 DBMS가 관리

## 03. 복구

### 3-1 데이터베이스에서의 장애

- ***복구 recovery***
    - ***장애 이전의 일관된 상태로 복원하는과정***
    - 복구의 기본 원리는 데이터의 중복 redundancy
        - back-up file
            - DVD나 자기 테이프와 같은 저장장치
        - mirroring
            - 하나의 데이터베이스를 서로 다른 디스크에 복제
            - 비용이 많이 듬
- 데이터베이스에서의 장애 failure 종류
    - ***트랜잭션 장애***
        - 트랜잭션 내의 논리적 오류나 잘못된 입력 데이터, 또는 시스템 내의 자원부족 등으로 인해 트랜잭션이 중단될 때 발생
    - ***시스템 장애***
        - 정전이나 하드웨어의 결함으로 인해 작동이 중단되는 경우
    - ***미디어 장애***
        - 디스크와 같은 비휘발성 저장장치의 일부 또는 전체가 손상된 상태
- 트랜잭션 장애, 시스템 장애의 경우
    - 원자성 특성을 만족시키기 위해,
    - ***로그 log***
        - ***트랜잭션이나 시스템 장애에 대비한 데이터베이스 갱신 이력 history 저장***
        - 장애 발생 이전에, 데이터베이스에 어떠한 순서로 갱신이 이루어졌는가를 나타내는 정보

### 3-2 데이터 입출력 방식

- 블록 block
    - 고정된 크기 단위
    - 디스크 사이의 입출력 작업의 단위
- 버퍼 buffer
    - 디스크의 입출력 작업을 최소화하고 성능을 극대화하기 위해
    - 버퍼의 내용이 언제 디스크에 기록되는지는 운영체제만이 알고 있음

### 3-3 로그의 구성요소

- 로그
    - 디스크에 저장되며 트랜잭션들의 모든 갱신 활동을 기록
    - 기록을 바탕으로 트랜잭션 실행 이전의 상태로 복귀할 수 있다.
- ***로그의 구성 요소***
    - ***트랜잭션의 시작 - <T start>***
    - ***트랜잭션의 완료 - <T commit>***
    - ***트랜잭션의 중단 - <T abort>***
    - ***데이터 항목에 대한 갱신 - <T, x, v1, v2>***
        - ***트랜잭션 T가 데이터 항목 x에 대해서 v1을 v2로 갱신했다는 의미***
- 트랜잭션에서 write()는 디스크가 아닌 버퍼에 저장한다는 사실을 기억하자
- ***로그 우선기록 규약 write-ahead logging protocol***
    - ***로그 레코드를 기록할 때 트랜잭션이 갱신한 데이터 항목을 디스크에 저장된 데이터베이스에 기록하기 전에 로그 레코드에 먼저 기록한다.***
        - 이미 기록된 내용을 취소하려면 로그 레코드에 그 기록이 남아 있어야 하기 때문
    - 이미 완료된 트랜잭션에 대해서 데이터베이스의 갱신 내용을 디스크에 반영할 때에도 유용하다
        - 트랜잭션의 변경이 버퍼에만 남아있다면 → 재가동 후 로그를 이용해 데이터베이스에 반영

### 3-4 로그를 이용한 복구 기법

- 복구를 위한 가장 기본적인 연산
    - ***UNDO***
        - ***갱신된 값을 그 이전의 값으로 되돌려 놓음***
    - ***REDO***
        - ***실제로 디스크로 반영이 안 됐을 경우 이를 재실행***
- 로그를 이용하여 복구하는 방법
    - 갱신 내용을 저장하는 시점에 따라
    - ***지연 갱신 deferred database modification***
    - ***즉시 갱신 immediate database modification***
- 지연 갱신을 기반으로 하는 복구 기법
    - ***지연갱신이란***
        - ***트랜잭션의 실행이 성공적으로 완료될 때까지 갱신 내용을 디스크에 저장하지 않고 지연시키는 방법***
    - 갱신된 내용은 주기억장치의 버퍼에 기록
    - ***트랜잭션 실행 과정***
        - ***트랜잭션 T가 시작되면 로그 레코드 <T start>를 로그에 기록***
        - ***T가 데이터 항목 x에 대해 쓰기 연산을 수행하면 로그에 그 내용이 기록되고, 주기억장치의 버퍼에 변경된 x 저장***
        - ***최종적으로 T가 모든 연산에 대한 실행을 마치면 T는 부분완료 상태가 되고, 로그 레코드 <T commit>을 로그에 기록***
        - ***<T commit>이 로그에 기록되면 T는 완료 상태가 되어 종료***
        - ***버퍼에 저장된 x를 이후 적당한 시기에 디스크에 저장***
    - Tip
        - ***트랜잭션이 완료되었다는 것은 디스크에 저장된 로그에 <T commit>이 기록되었다는 것을 의미***
    - UNDO 연산 불필요, REDO 연산 필요
    - 데이터 갱신에 의한 로그 레코드 형식
        - ***<T, x, v2>***
    - ***복구 과정***
        - ***로그 파일의 처음부터 기록을 순차적으로 검색***
        - ***로그에 저장된 각 트랜잭션 T의 로그 레코드에 대해 <T commit>이 저장되었다면 이 트랜잭션의 갱신 기록에 대해 REDO 연산 수행***
        - ***<T commit>이 없는 나머지 트랜잭션에 대한 로그 레코드들은 무시***
    - 지연 갱신을 기반으로 한 복구 알고리즘은 UNDO 연산이 필요 없으므로 ***NO-UNDO/REDO 알고리즘***이라고한다.
    - 예제 p399~400
- 즉시 갱신을 기반으로 하는 복구 기법
    - ***즉시 갱신이란***
        - ***트랜잭션의 수행 도중에 언제든지 데이터의 갱신 내용은 디스크에 저장될 수 있다.***
        - 지연 갱신과는 달리 버퍼에서 갱신된 데이터들이 트랜잭션 실행 도중에 디스크에 저장되는지 또는 완료된 후에 저장되는지에 대한 특별한 제한을 두지 않는다.
    - ***UNDO, REDO 연산 모두 필요***
    - 데이터 갱신에 의한 로그 레코드 형식
        - ***<T, x, v1, v2>***
    - ***복구 과정***
        - ***로그 파일이 기록된 마지막부터 반대 방향으로 순차적 검색***
        - ***로그에 저장된 각 트랜잭션 T의 로그 레코드에 대해 <T start>가 있으나 <T commit>이 없으면 이 트랜잭션의 갱신 기록에 대해서 UNDO 연산 수행***
        - ***로그 파일의 처음에 도달했으면 반대 방향으로 순차적으로 검색***
        - ***로그에 저장된 각 트랜잭션의 로그 레코드에 대해 <T commit>이 저장되었으면 이 트랜잭션의 갱신 기록에 대해 REDO 연산 수행***
    - 즉시 갱신을 기반으로 한 알고리즘을 ***UNDO/REDO 알고리즘***이라 한다.
    - 예제 p401~402
- 검사점을 이용한 복구
    - 로그의 크기가 커질수록 복구 부담 증가
    - 불필요한 REDO 연산 다량 증가
    - ***검사점 breakpoint***
        - ***주기적으로 디스크에 갱신된 내용을 모두 디스크에 기록하는 시점***
    - 검사점 이전 로그에 대해서는 REDO, UNDO 불필요
    - ***검사점 작업 (즉시 갱신만을 가정)***
        - 모든 트랜잭션의 실행을 중단
        - 갱신된 모든 버퍼의 내용을 디스크로 출력
        - 로그에 <checkpoint>라는 레코드를 저장
        - 중단된 트랜잭션들을 다시 실행
    - ***검사점 복구 기법***
    
    ![Untitled](Untitled%2012.png)
    
    - 예제 p404~405
    

## 04. 오라클에서의 트랜잭션

### 4-1 트랜잭션의 완료와 복귀

DML - 테이블에 대한 읽기, 쓰기 연산

DDL - 데이터베이스 스키마 변경에 관한 명령

DCL - 권한 관련 명령

- DDL, DCL의 경우
    - auto commit
    - 성공적으로 실행된 경우 복구 불가능
- DML의 경우
    - commit, rollback 명령 사용
    - commit : 트랜잭션 종료
        
        ![Untitled](Untitled%2013.png)
        
    - rollback : 가장 최근 commit 시점까지 복구
        
        ![Untitled](Untitled%2014.png)
        
- 오라클 예제 p408~410

### 4-2 자동 완료와 자동 복귀 p410~412

- auto commit
    - commit을 실행하지 않더라도 정상적으로 종료되면 트랜잭션도 자동으로 완료
    - DDL, DCL에서는 항상 자동 완료
- auto rollback
    - 비정상적으로 종료되면 트랜잭션은 자동 복귀
- ***set autocommit on***
    - ***위 명령어 사용시, DML에서도 자동 완료를 할 수 있다.***
- ***오라클에서 트랜잭션이 자동 완료되는 경우***
    - ***SQL*Plus가 정상적으로 종료***
    - ***DDL, DCL 명령 실행***
    - ***set autocommit on 설정 → 개별 DML 자동 완료***

### 4-3 트랜잭션의 고립성 확인

### 4-4 저장점 p414~415

- ***저장점 savepoint***
    - ***오라클에서는 하나의 트랜잭션을 분할하여 트랜잭션의 일부만을 복귀시킬 수 있는 수단을 제공***
- 저장점 지정
    - savepoint <저장점이름>
- 저장점으로 복귀
    - rollback to <저장점이름>