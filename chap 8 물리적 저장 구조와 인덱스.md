# chap 8 : 물리적 저장 구조와 인덱스

## 01 데이터베이스의 물리적 저장구조

- 물리적 데이터베이스 physical database
    - 테이블과 레코드들은 최종적으로 디스크에 저장되어 관리
    - 저장 매체 관점에서 살펴본 데이터베이스의 형태
- 기본 저장구조는 파일, 입출력 단위는 고정 크기인 블록
    - ***파일***
        - 모든 데이터는 파일 형태로 기록
        - 하나 또는 하나 이상의 테이블들이 저장
    - ***블록***
        - 하나의 블록에는 하나 또는 하나 이상의 레코드들이 저장
        - 각 블록은 하나의 테이블에 속함
- 블록 내 레코드 저장 방식 p337
    - 블록 내에 ***고정길이***로 저장된 레코드
        - 고정길이 char()
        - 레코드 읽기 쉽다
        - 공간 낭비
    - 블록 내에 ***가변길이***로 저장된 레코드
        - 가변길이 varchar2()
        - 공간 활용에 좋다
        - 각 레코드 사이의 경계를 알 수 없다
            - 블록 끝에 offset을 두어 끝나는 지점 저장

```sql
create table course (
	course_id varchar2(4),
	title varchare2(20),
	credit int
)
```

- ***클러스터링*** p338
    - 검색을 빨리하기 위해
    - 자주 검색되는 필드를 기준으로 관련 레코드들을 같은 블록에 저장
    - 동시에 사용되는 레코드들을 서로 인접하여 위치하게 함
    - 클러스터링을 통해 연산을 줄여 탐색 시간을 줄일 수 있다.

## 02 인덱스

### 2-1 인덱스를 이용한 데이터 접근

빠른 검색을 위한 간단한 방법

- 검색 필드로 사전 정렬 및 이진 탐색 binary search
- 검색 필드 종류가 많으면?
    - 별도의 검색을 위한 자료구조 생성 → 인덱스
- ***인덱스***
    - ***레코드들에 대한 검색 속도를 높이기 위해 레코드에 대한 물리적 저장 위치를 별도로 기록한 구조***
    - 인덱스가 없다면, 모든 블록들을 순차적으로 검색해야 함
    - 인덱스의 예
        - 도서관의 책 정렬
        - 사전의 단어 정렬
- 데이터베이스의 인덱스
    - 레코드에 대한 물리적 저장위치를 별도로 기록
    - 인덱스의 구조
        - ***인덱스 엔트리*** : (검색키, 주소)
        - ***검색키*** : 테이블에 속한 한 개 이상의 필드
- SQL과 인덱스
    - student 테이블의 레코드 수 10000개
    - dept_id가 920인 레코드 수 500개
    - 인덱스가 없을 경우
        - 모든 레코드를 순차 검색
    - dept_id에 인덱스가 있을 경우
        - dept_id가 920인 레코드만 검색

```sql
select *
from student
where dept_id='920' and address='서울'
```

- SQL 조인 연산과 인덱스
    - 인덱스가 없을 경우
        - 모든 레코드를 순차 검색
        - 시간 비용 : ***10000*100***에 비례
    - student 테이블에 dept_id 필드에 인덱스가 있을 경우
        - department 테이블 레코드 수만큼만 검색
        - 시간 비용 : ***10000+100***에 비례
    - 결론
        - 조인 연산의 속도를 높이기 위해 조인 조건에 참여하는 필드에 대해 인덱스를 구축해 놓는 것이 매우 유리하다.

```sql
select count(*)
from student s, department d
where address='서울' and s.dept_id=d.dept_id
```

- 질의 4
    - 인덱스가 없을 경우
        - student 테이블 모든 레코드 검색
    - dept_id 테이블에 인덱스가 있을 경우
        - 인덱스에서 각 dept_id별로 인덱스 엔트리의 개수를 세면 됨
        - 인덱스만으로 질의 처리 가능

```sql
select dept_id, count(*)
from student
group by dept_id
```

- 기본키와 인덱스
    - 기본키
        - 레코드 검색의 기준이 되는 필드
        - 대부분의 DBMS에서 테이블을 생성할 때 기본키에 대한 인덱스는 자동적으로 생성
    - 인덱스의 장단점
        - 장점
            - 검색 속도 향상
        - 단점
            - 테이블에서 레코드의 삽입, 수정, 삭제에 따라 관련 인덱스 구조가 변경되어야 한다.
            - 인덱스가 많아지면 삽입, 삭제, 수정 연산 속도 저하

### 2-2 B+ 트리 인덱스 p343~345

RDBMS에서 인덱스로 자주 사용되는 자료구조

- 트리 형태 구조
- ***차수 degree***
    - 한 노드에서 하위 자식 노드를 가리키는 주소의 개수
- 차수가 n인 B+트리의 중간 노드 구조
    
    ![Untitled](Untitled%205.png)
    
- 차수가 n인 B+트리의 특징

![Untitled](Untitled%206.png)

- B+ 트리의 성능
    - department 테이블이 10,000개의 레코드를 갖고, 이중에서 ‘컴퓨터 공학과' 레코드를 검색한다고 가정
    - 인덱스가 없다면
        - 최악의 경우 10,000개 검색
    - dept_name 필드에 차수가 10인 B+ 인덱스가 있다면
        - 차수 : 10, 검색키의 수 : 10,000
        - B+ : 트리의 높이는 최대 6을 넘지 않음

### 2-3 복합 인덱스 p345~348

- ***복합 인덱스 composite index***
    - 두 개 이상의 필드에 대해 하나의 인덱스 생성
    - 엔트리들은 검색키 값의 순서대로 정렬
- 엔트리 정렬 방법
    - 검색 키 값이 문자열인 경우 사전식 정렬 lexicographic ordering 사용
    - 숫자인 경우 크기로 정렬
    - 문자열/숫자가 아닌 경우 대소관계 정의 필요
    - 예제 p346 참고
- 복합 인덱스 효과 p347~348 반드시 읽기
    - 복합키에 대한 복합 인덱스를 구축하였다면 두 조건을 모두 만족하는 레코드를 하나의 인덱스로 찾을 수 있기 때문에 단일 필드로 구성된 인덱스에 의한 질의 처리에 비해 그 효과가 더 클 것이다.

### 2-4 해시 인덱스 p348~351

- ***해시 인덱스***
    - 해시 함수를 기반으로 인덱스 엔트리를 구성
- ***버켓 bucket***
    - 인덱스 엔트리가 저장되는 공간
    - 버켓 번호 : 해시 함수 값
- 해시 인덱스 구성 및 사용 방법
    - 인덱스 구성 방법
        - 인덱스 구성에 사용될 필드 결정
        - 필드 값에 해시 함수 적용하여 버켓 번호 생성
        - 인덱스 엔트리를 생성하여 해당 버켓에 저장
    - 인덱스 사용 방법
        - 검색할 값을 해시 함수에 적용하여 버켓 번호 생성
        - 해당 버켓안에 들어 있는 인덱스 엔트리 검색
- 해시 함수 hash function
    - 대규모의 데이터 키 집합을 적은 범위의 데이터 집합으로 대응시키는 함수
    - 해시 값은 균등하게 분포되어야 함
- ***버켓 오버플로우 overflow***
    - 하나의 버켓에는 저장 가능한 엔트리 개수가 있음
    - 버켓 오버플로우
        - 버켓에 할당된 엔트리가 다 차는 경우
        - 새로운 버켓을 생성하여 기존 버켓과 연결
        - 오버플로우가 많이 발생할수록 해시 인덱스 성능 저하
    - 해시 함수와 버켓 오버플로우
        - 해시 함수의 균등성이 좋을수록 오버플로우 적음
        - 해시 함수의 균등성이 나쁠수록 오버플로우 빈번함
- B+트리 인덱스 vs 해시 인덱스
    - 해시 인덱스
        - 동등 조건에 해당하는 레코드를 찾는 경우
    - B+ 트리 인덱스
        - 범위 조건을 포함한 질의

### 2-5 밀집도와 클러스터링에 따른 인덱스의 분류

- 대응 밀집도에 따라
    - ***희소 sparse 인덱스***
        - 테이블의 일부 레코드에 대해 인덱스 엔트리 생성
        - 트리 규모 작음
    - ***밀집 dense 인덱스***
        - 테이블의 모든 레코드에 대해 인덱스 엔트리 생성
        - 트리 규모 큼
- 클러스터링 유무에 따라
    - ***클러스터 clustered 인덱스***
        - 1차 인덱스
        - 필드 값의 순서에 따라서 레코드를 저장
        - 범위 조건 검색, order by절에 효과적
        - 질의 성능 우수
        - 클러스터 인덱스 구성을 위해 테이블에 포함된 레코드들의 물리적 위치 조정 필수
            - 따라서 한 테이블에서 두 개 이상의 클러스터 인덱스를 설정하는 것은 불가능
    - ***비클러스터 un-clustered 인덱스***
        - 2차 인덱스
        - 필드 값의 순서와 상관없이 레코드 저장
        - 따라서 밀집 인덱스를 가져야 한다.

## 03 오라클에서의 인덱스의 설정

- 인덱스 생성 구문
    - unique
        - 해당 필드 값이 중복되지 않을 때
        - 레코드 삽입 시 필드 값이 중복되지 않는지 자동으로 체크

```sql
create index <인덱스 이름> on <테이블이름> <필드리스트>
create index dept_index on department(dept_name)
create unique index dept_index2 on department(dept_name)
```

- 복합인덱스

```sql
create index student_index2 on student(name, address)
```

- 인덱스 삭제 구문

```sql
drop index <인덱스 이름>
drop index dept_index
```

- 인덱스를 설정해야 하는 경우
    - 테이블의 레코드 수가 많을 때
    - where절에 자주 사용되는 필드
    - 조인 연산에 참여하거나 널 값이 많은 필드
- 인덱스를 설정하지 않는 경우
    - 테이블의 레코드 수가 적을 때
    - where절에 거의 사용하지 않는 필드
    - 삽입, 삭제, 수정이 자주 발생하는 테이블
    - 테이블 내에 서로 구별되는 값의 개수가 적은 필드
        - ex) 성별을 나타내는 남 또는 여 두 개의 값만을 가지는 필드
        - bitmap index